[{"path":"https://bayesiandemography.github.io/smoothscale/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 International Labour Organization Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://bayesiandemography.github.io/smoothscale/articles/smoothscale-models.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Statistical Models used for Smoothing and Scaling","text":"smoothscale package provides functions estimating counts prevalences small populations. functions deal two problems often arise sort estimation: sampling errors measurement errors. Statisticans developed many methods estimation small populations, headings “small area estimation” (Rao Molina 2015). Many methods complex, require specialist statistical skills. methods used smoothscale , contrast, deliberately simple. vignette defines sampling measurement errors, describes dealt functions smoothscale. vignette discusses two issues: stratification additional variables age sex/gender, interactions sampling measurement errors.","code":""},{"path":[]},{"path":"https://bayesiandemography.github.io/smoothscale/articles/smoothscale-models.html","id":"the-setting","dir":"Articles","previous_headings":"Sampling Errors","what":"The setting","title":"Statistical Models used for Smoothing and Scaling","text":"like estimate prevalence attribute, employment school attendance, \\(k = 1, \\dots, K\\) small areas. interested absolute numbers underlying probabilities. data \\(n_k\\) people area. number people area reported attribute question \\(x_k\\). following hypothetical data, instance, \\(n_k\\) number respondents distribution, \\(x_k\\) number respondents attend school: data come census administrative system, number repondents may approximately equal size target population area. number children captured census, instance, close actual number children living area. , however, data come sample extracted census, number respondents likely much smaller number people target population. case, estimate counts people attribute area, need additional set data, \\(N_k\\), \\(k = 1, \\cdots, K\\), size target population area. Data target population school-age children, instance, might look like : Observed prevalences always, extent, reflect random variation. Whether particular child involved child labour, instance, depends partly random factors economic status child’s family. data come survey, sample selection procedures add randomness. can therefore think number people attribute reflecting stable ‘expected’ value, random error. Similarly, proportion people area attribute reflects underlying propensity attribute, random error. small populations, can essential distinguish observed proportion underlyign propensity. Consider, instance, population 10 people , given yer, one dies. observed proportion people dying year zero. However underlying propensity – risk dying people fact faced year – zero. large populations, random errors tend cancel , observed counts can reliable indicators underlying propensities. small populations, much less scope cancellation, observed counts much noisy. statistical challenge minimise effects noise, get underlying expected values propensities.","code":""},{"path":"https://bayesiandemography.github.io/smoothscale/articles/smoothscale-models.html","id":"statistical-model","dir":"Articles","previous_headings":"Sampling Errors","what":"Statistical model","title":"Statistical Models used for Smoothing and Scaling","text":"Function smooth_prob() produces smoothed estimates try strip effects random variation. model draws ideas Bayesian statistics (Gelman et al. 2014), contrast fully Bayesian analysis, smooth_prob() yields point estimates. estimates based statistical model. number people area \\(k\\) attribute interest treated random draw binomial distribution, \\[\\begin{equation}   x_k \\sim \\text{Binomial}(n_k, \\pi_k), \\end{equation}\\] \\(\\pi_k\\) probability attribute. job smooth_prob() estimate \\(\\pi_k\\) \\(K\\) areas. Function smooth_prob() assumes \\(\\pi_k\\) come beta distribution, \\[\\begin{equation}   \\pi_k \\sim \\text{Beta}(\\alpha, \\beta). \\end{equation}\\] centre distribution, extent values concentrate around centre, determined parameters \\(\\alpha\\) \\(\\beta\\). Values parameters estimated data. Rather work directly \\(\\alpha\\) \\(\\beta\\), express terms two new parameters, \\[\\begin{align}   \\alpha & = \\lambda \\nu \\\\   \\beta & = (1 - \\lambda) \\nu \\end{align}\\] Parameter \\(\\lambda\\) central value \\(\\pi_k\\), parameter \\(\\nu\\) governs tightly \\(\\pi_k\\) concentrated around \\(\\lambda\\), larger values implying greater concentration. place constraints \\(\\lambda\\), except restrict range \\(0 < \\lambda < 1\\). assume \\(\\nu\\) parameter comes log-normal distribution, \\[\\begin{equation}   \\nu \\sim \\text{LogNormal}(\\log 10, 1). \\end{equation}\\] distributional assumptions \\(\\nu\\) virtually impact estimates \\(\\pi_k\\), except number small areas population area small. Placing soft constraint \\(\\nu\\) , however, help stabilise estimates reasonable values counts small. Fitted values \\(\\lambda\\) \\(\\nu\\) can obtained finding values maximise quantity \\[\\begin{equation}   \\prod_{k=1}^K \\text{BetaBinom}(x_k | n_k, \\lambda \\nu, (1 - \\lambda) \\nu) \\text{LogNormal}(\\nu | \\log 10, 1). \\end{equation}\\] quantity proportional posterior distribution, , non-Bayesian terms, penalised likelihood. See Wikipedia contributors (2023a) definition beta-binomial distribution. Values \\(\\pi_k\\) can derived using properties binomial beta distributions (Wikipedia contributors 2023b). fitted value \\(\\pi_k\\) \\[\\begin{equation}   \\hat{\\pi}_k = \\frac{x_k + \\lambda \\nu}{n_k + \\nu} (\\#eq:pihat) \\end{equation}\\] smoothed value number people attribute \\(\\hat{\\pi}_k N_k\\), , data complete enumeration population, \\(\\hat{\\pi}_k n_k\\).","code":""},{"path":"https://bayesiandemography.github.io/smoothscale/articles/smoothscale-models.html","id":"partial-pooling","dir":"Articles","previous_headings":"Sampling Errors","what":"Partial pooling","title":"Statistical Models used for Smoothing and Scaling","text":"formula \\(\\hat{\\pi}_k\\) given @ref(eq:pihat) can rewritten \\[\\begin{equation}   \\hat{\\pi}_k = \\phi_k \\frac{x_k}{n_k} + (1 - \\phi_k) \\hat{\\lambda}     (\\#eq:partial) \\end{equation}\\] \\[\\begin{equation}   \\phi_k = \\frac{n_k}{n_k + \\hat{\\nu}_k}. \\end{equation}\\] quantity \\(\\frac{x_k}{n_k}\\) @ref(eq:partial) traditional ‘direct’ estimate probability area \\(k\\). direct estimate based entirely data area \\(k\\), smoothing. parameter \\(\\hat{\\lambda}\\) estimate average value across areas, uses available data. parameter \\(\\phi_k\\) type weight, close 1 \\(n_k\\) large, close 0 \\(n_k\\) small. Equation @ref(eq:partial) shows \\(\\hat{\\pi}_k\\) can regarded compromise local estimate \\(\\frac{x_k}{n_k}\\) global estimate \\(\\hat{\\lambda}\\). way weights \\(\\phi_k\\) constructed means local estimate exerts greater influence data support , less influence less data support . data-driven balancing local global estimates common small area estimation, known, among things, “partial pooling”. Partial pooling makes intuitive sense, usually performs well practice. characteristic partially-pooled estimates tightly concentrated direct estimates. form smoothing, also referred shrinkage regularisation. estimator @ref(eq:partial) property. Partial pooling shifts \\(\\pi_k\\) towards \\(\\hat{\\lambda}\\), concentrated direct estimates \\(\\frac{x_k}{n_k}\\).","code":""},{"path":[]},{"path":"https://bayesiandemography.github.io/smoothscale/articles/smoothscale-models.html","id":"setting","dir":"Articles","previous_headings":"Measurement error","what":"Setting","title":"Statistical Models used for Smoothing and Scaling","text":"second sort error often affects small area estimates measurement error. Measurement error can occur, instance, respondents misunderstand question, proxy respondents used, definitions used data different ones required analysis. Accounting measurement errors normally requires sort additional data true underlying values. Function scale_prob(), function smoothscale deals measurement error, requires reliable data national-level prevalences. typical source reliable national-level data household surveys. Although household surveys large enough samples provide stable estimates small areas, typically large enough samples provide stable estimates national level, also relatively low measurement errors.","code":""},{"path":"https://bayesiandemography.github.io/smoothscale/articles/smoothscale-models.html","id":"model","dir":"Articles","previous_headings":"Measurement error","what":"Model","title":"Statistical Models used for Smoothing and Scaling","text":"Let \\(p_k\\) initial estimate probability person area \\(k\\) possesses attribute question. think \\(p_k\\) differs true value \\(\\pi_k\\) measurement error, , \\[\\begin{equation}   \\pi_k = p_k + \\epsilon_k, \\end{equation}\\] \\(\\epsilon_k\\) area-level measurement error. estimate \\(\\pi_k\\), need way estimating \\(\\text{epsilon}_k\\). Let \\[\\begin{equation}   w_k = \\frac{N_k}{\\sum_{k=1}^K N_k} \\quad \\text{} \\quad \\frac{n_k}{\\sum_{k=1}^K n_k}, \\quad k = 1, \\cdots, K, \\end{equation}\\] known set population weights. Let \\[\\begin{equation}   \\bar{p} = \\sum_{k=1}^K w_k p_k \\end{equation}\\] national-level probability obtained averaging initial area-level estimates, let \\[\\begin{equation}   \\bar{\\pi} = \\sum_{k=1}^K w_k \\pi_k \\end{equation}\\] true national-level probability. can obtain accurate estimate \\(\\hat{\\pi}\\) , instance, national-level survey, though know individual \\(\\pi_k\\). national estimate, can calculate average error, \\[\\begin{equation}   \\bar{\\epsilon} = \\sum_{k=1}^K w_k \\epsilon_k = \\sum_{k=1}^K w_k (\\pi_k - p_k) = \\sum_{k=1}^K w_k \\pi_k - \\sum_{k=1}^K w_k p_k = \\bar{\\pi} - \\bar{p}. (\\#eq:epsilon) \\end{equation}\\] like construct estimator \\(\\epsilon_k\\) form \\[\\begin{equation}   \\epsilon_k = \\alpha_k \\bar{\\epsilon} \\end{equation}\\] \\(\\alpha_k\\) area-specific scaling factor. estimator implemented scale_prob() takes slightly different forms average error positive (need scale upwards) average error negative (need scale downwards): \\[\\begin{equation}   \\alpha_k = \\begin{cases}     \\displaystyle \\frac{1 - p_k}{1 - \\bar{p}}  & \\text{} \\bar{\\epsilon} > 0 \\\\     \\displaystyle \\frac{p_k}{\\bar{p}}  & \\text{} \\bar{\\epsilon} < 0.     \\end{cases} \\end{equation}\\] scaling factor \\(\\alpha_k\\) irrelevant \\(\\bar{\\epsilon} = 0\\), case scaling necessary. national-level error \\(\\bar{\\epsilon}\\) positive, \\(\\alpha_k\\) non-negative, \\(\\pi_k\\) always greater equal \\(p_k\\). Conversely, \\(\\bar{\\epsilon}\\) negative, \\(\\alpha_k\\) non-positive, \\(\\pi_k\\) always less equal \\(p_k\\). scale_prob() estimator \\(\\pi_k\\) passes basic sanity checks: adjusting upwards, \\(\\pi_k\\) never exceeds 1, adjusting downwards, \\(\\pi_k\\) less never less 0, adjusting either direction, \\(\\epsilon_k\\) always sum \\(\\bar{\\epsilon}\\) defined @ref(eq:epsilon). (See Appendix details.) estimator also smooths estimates, relative original \\(\\pi_k\\), pulling towards central value. adjusting upwards, size adjustment proportional \\(1 - p_k\\), implying unusually low values get large adjustments, unusually high values get small adjustments. adjusting downwards, size adjustment proportional \\(p_k\\), implying unusually high values get large adjustments, unusually low values get small adjustments. adjustment process pulls extreme values towards centre, reminiscent shrinkage occurs partial pooling. assume extreme symptom measurement error, smoothing behaviour , average, appropriate.","code":""},{"path":"https://bayesiandemography.github.io/smoothscale/articles/smoothscale-models.html","id":"stratification","dir":"Articles","previous_headings":"","what":"Stratification","title":"Statistical Models used for Smoothing and Scaling","text":"Often data also disaggregated subpopulation. instance, data disaggregated age sex might look like : national-level prevalences required scale_prob() might like : smoothscale takes simple approach disaggregated: estimates constructed completely independently combination stratifying variables. instance, data , estimates constructed separately 5-9 year old females, 5-9 year old males, 10-14 year old females, 10-14 year old males. Although might gains accuracy stability sharing information across combinations variables, mean sacrificing simplicity usability.","code":""},{"path":"https://bayesiandemography.github.io/smoothscale/articles/smoothscale-models.html","id":"combinations-of-sampling-and-measurement-error","dir":"Articles","previous_headings":"","what":"Combinations of sampling and measurement error","title":"Statistical Models used for Smoothing and Scaling","text":"derivation estimator used smooth_prob() refers sampling error, derivation estimator used scale_prob() refers measurement error. data subject substantial sampling error measurement error? principle, might advantages modelling sampling error measurement error simultaneously. However, require extra assumptions nature measurement errors, ways interacted sample size. recommended approach smoothscale instead use smooth_prob() deal sampling error, use scale_prob() deal measurement error. approach much simpler, given difficulty formulating assuptions measurement errors, probably just accurate.","code":""},{"path":"https://bayesiandemography.github.io/smoothscale/articles/smoothscale-models.html","id":"appendix-sanity-checks-for-scale_prob-estimator","dir":"Articles","previous_headings":"","what":"Appendix: Sanity checks for scale_prob() estimator","title":"Statistical Models used for Smoothing and Scaling","text":"adjusting upwards, \\(\\pi_k\\) never greater 1, since \\[\\begin{equation}   \\pi_k = p_k + \\frac{1 - p_k}{1 - \\bar{p}} (\\bar{\\pi} - \\bar{p}) \\le p_k + \\frac{1 - p_k}{1 - \\bar{p}} (1 - \\bar{p}) = p_k + 1 - p_k = 1. \\end{equation}\\] Similarly, adjusting dowwards, \\(\\pi_k\\) less never 0, since \\[\\begin{equation}   \\pi_k = p_k + \\frac{p_k}{\\bar{p}} (\\bar{\\pi} - \\bar{p}) \\ge p_k + \\frac{p_k}{\\bar{p}} (-\\bar{p}) = p_k - p_k = 0. \\end{equation}\\] addition, adusting upwards, \\[\\begin{equation}    \\sum_{k=1}^K w_k \\epsilon_k = \\sum_{k=1}^K w_k \\frac{1 - p_k}{1 - \\bar{p}} \\bar{\\epsilon} = \\frac{1 - \\bar{p}}{1 - \\bar{p}} \\bar{\\epsilon} = \\bar{\\epsilon}, \\end{equation}\\] , adusting downwards, \\[\\begin{equation}    \\sum_{k=1}^K w_k \\epsilon_k = \\sum_{k=1}^K w_k \\frac{p_k}{\\bar{p}} \\bar{\\epsilon} = \\frac{\\bar{p}}{\\bar{p}} \\bar{\\epsilon} = \\bar{\\epsilon}, \\end{equation}\\] required.","code":""},{"path":[]},{"path":"https://bayesiandemography.github.io/smoothscale/articles/smoothscale-using.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Using Package 'smoothscale'","text":"Package smoothscale contains functions simple small area estimation data sampling errors /measurement errors. vignette demonstrates use functions, using synthetic data. First load package. using datasets syn_census syn_survey. datasets contains synthetic (.e. fake) data, data similar structure real census survey data. syn_census contains, combination area, age, sex, counts children involved child labour, counts children. syn_survey contains estimates overall probabilities involved child labour, assumed accurate.","code":"library(smoothscale) syn_census #> # A tibble: 100 × 5 #>    area    age   sex    child_labour all_children #>    <chr>   <chr> <chr>         <int>        <dbl> #>  1 Area 01 5-9   Female          134          372 #>  2 Area 02 5-9   Female           14           35 #>  3 Area 03 5-9   Female           92          388 #>  4 Area 04 5-9   Female           46          345 #>  5 Area 05 5-9   Female           25          102 #>  6 Area 06 5-9   Female            2            5 #>  7 Area 07 5-9   Female            4           13 #>  8 Area 08 5-9   Female           10           34 #>  9 Area 09 5-9   Female            2           52 #> 10 Area 10 5-9   Female          578         2087 #> # ℹ 90 more rows"},{"path":"https://bayesiandemography.github.io/smoothscale/articles/smoothscale-using.html","id":"function-smooth_prob","dir":"Articles","previous_headings":"","what":"Function smooth_prob()","title":"Using Package 'smoothscale'","text":"Function smooth_prob() deals sampling error, typically important problem small area estimation. Function smooth_prob() two main arguments: count count variable needs smoothed, case, counts child labour size number respondents counts draw, case, counts children census file. ‘direct’ estimate probability child involved child labour can produced simply dividing area’s count child labour number children, smoothed version estimates can produced using function smooth_prob(): Function smooth_prob() pulls prevalences (ie counts divided size) towards overall average. know, however, child labour likely vary age sex. better smooth combination age sex towards average. convenient way smooth within combinations variables use functions contained dplyr package (part thetidyverse.) calculate plot prevalences, using tidyverse packages functions,","code":"direct <- syn_census$child_labour / syn_census$all_children summary(direct) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>  0.0000  0.1885  0.2500  0.2651  0.3170  0.8000 smoothed <- smooth_prob(x = syn_census$child_labour,                         size = syn_census$all_children) summary(smoothed) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>  0.1053  0.2137  0.2537  0.2645  0.2978  0.5186 library(dplyr) #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union smoothed_agesex <- syn_census |>   group_by(age, sex) |>   mutate(direct = child_labour / all_children,          smoothed = smooth_prob(x = child_labour,                                 size = all_children)) |>   ungroup() smoothed_agesex #> # A tibble: 100 × 7 #>    area    age   sex    child_labour all_children direct smoothed #>    <chr>   <chr> <chr>         <int>        <dbl>  <dbl>    <dbl> #>  1 Area 01 5-9   Female          134          372 0.360    0.351  #>  2 Area 02 5-9   Female           14           35 0.4      0.325  #>  3 Area 03 5-9   Female           92          388 0.237    0.236  #>  4 Area 04 5-9   Female           46          345 0.133    0.140  #>  5 Area 05 5-9   Female           25          102 0.245    0.241  #>  6 Area 06 5-9   Female            2            5 0.4      0.252  #>  7 Area 07 5-9   Female            4           13 0.308    0.252  #>  8 Area 08 5-9   Female           10           34 0.294    0.264  #>  9 Area 09 5-9   Female            2           52 0.0385   0.0995 #> 10 Area 10 5-9   Female          578         2087 0.277    0.276  #> # ℹ 90 more rows library(tidyr) library(forcats) library(ggplot2) data_for_plot <- smoothed_agesex |>   pivot_longer(col = c(direct, smoothed),                names_to = \"measure\",                  values_to = \"prob\") |>   mutate(area = fct_reorder(area, prob)) ggplot(data_for_plot,        aes(x = prob, y = area, color = measure)) +   facet_grid(vars(age), vars(sex)) +   geom_point() +   scale_color_manual(values = c(\"darkblue\", \"darkorange\"))"},{"path":"https://bayesiandemography.github.io/smoothscale/articles/smoothscale-using.html","id":"function-scale_prob","dir":"Articles","previous_headings":"","what":"Function scale_prob()","title":"Using Package 'smoothscale'","text":"Function scale_prob() deals measurement error, also arises often small area estimation. Function scale_prob() three arguments: prob_unscaled original probability estimate area prob_target overall probability, assumed error-free wt optional weighting variable, used calculate overall probability prob_unscaled. can use scale_prob() scale probabilities estimated earlier using smooth_prob() match syn_survey national level. graph results.","code":"scaled_agesex <- smoothed_agesex |>   inner_join(syn_survey) |>   group_by(age, sex) |>   mutate(scaled = scale_prob(prob_unscaled = smoothed,                              prob_target = prob_child_labour)) %>%   ungroup() #> Joining with `by = join_by(age, sex)` scaled_agesex  #> # A tibble: 100 × 9 #>    area  age   sex   child_labour all_children direct smoothed prob_child_labour #>    <chr> <chr> <chr>        <int>        <dbl>  <dbl>    <dbl>             <dbl> #>  1 Area… 5-9   Fema…          134          372 0.360    0.351              0.297 #>  2 Area… 5-9   Fema…           14           35 0.4      0.325              0.297 #>  3 Area… 5-9   Fema…           92          388 0.237    0.236              0.297 #>  4 Area… 5-9   Fema…           46          345 0.133    0.140              0.297 #>  5 Area… 5-9   Fema…           25          102 0.245    0.241              0.297 #>  6 Area… 5-9   Fema…            2            5 0.4      0.252              0.297 #>  7 Area… 5-9   Fema…            4           13 0.308    0.252              0.297 #>  8 Area… 5-9   Fema…           10           34 0.294    0.264              0.297 #>  9 Area… 5-9   Fema…            2           52 0.0385   0.0995             0.297 #> 10 Area… 5-9   Fema…          578         2087 0.277    0.276              0.297 #> # ℹ 90 more rows #> # ℹ 1 more variable: scaled <dbl> data_for_plot_scaled <- scaled_agesex |>   pivot_longer(col = c(direct, smoothed, scaled),                names_to = \"measure\",                  values_to = \"prob\") |>   mutate(measure = factor(measure, levels = c(\"direct\", \"smoothed\", \"scaled\")),          area = fct_reorder(area, prob)) ggplot(data_for_plot_scaled,        aes(x = prob, y = area, color = measure)) +   facet_grid(vars(age), vars(sex)) +   geom_point() +   scale_color_manual(values = c(\"darkblue\", \"darkorange\", \"darkgreen\"))"},{"path":"https://bayesiandemography.github.io/smoothscale/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"John Bryant. Maintainer.","code":""},{"path":"https://bayesiandemography.github.io/smoothscale/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Bryant J (2023). smoothscale: Smooth Counts Scale Benchmarks. R package version 0.1.0, https://bayesiandemography.github.io/smoothscale/.","code":"@Manual{,   title = {smoothscale: Smooth Counts and Scale to Benchmarks},   author = {John Bryant},   year = {2023},   note = {R package version 0.1.0},   url = {https://bayesiandemography.github.io/smoothscale/}, }"},{"path":"https://bayesiandemography.github.io/smoothscale/index.html","id":"smoothscale","dir":"","previous_headings":"","what":"Smooth Counts and Scale to Benchmarks","title":"Smooth Counts and Scale to Benchmarks","text":"Simple small area estimation methods.","code":""},{"path":"https://bayesiandemography.github.io/smoothscale/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Smooth Counts and Scale to Benchmarks","text":"","code":"devtools::install_github(\"bayesiandemography/smoothscale\")"},{"path":"https://bayesiandemography.github.io/smoothscale/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Smooth Counts and Scale to Benchmarks","text":"","code":"library(smoothscale) library(dplyr, warn.conflicts = FALSE) syn_census %>%   inner_join(syn_survey, by = c(\"age\", \"sex\")) %>%   group_by(age, sex) %>%   mutate(child_labour_sm = smooth_prob(x = child_labour,                                        size = all_children)) #> # A tibble: 200 × 8 #> # Groups:   age, sex [4] #>    area    age   sex    child_labour all_children total_child_labour #>    <chr>   <chr> <chr>         <int>        <dbl>              <dbl> #>  1 Area 01 5-9   Female           42          368             222365 #>  2 Area 02 5-9   Female           10           33             222365 #>  3 Area 03 5-9   Female          112          453             222365 #>  4 Area 04 5-9   Female          151          354             222365 #>  5 Area 05 5-9   Female           23          101             222365 #>  6 Area 06 5-9   Female            3            5             222365 #>  7 Area 07 5-9   Female            3           14             222365 #>  8 Area 08 5-9   Female            6           35             222365 #>  9 Area 09 5-9   Female           14           48             222365 #> 10 Area 10 5-9   Female          422         1889             222365 #> # ℹ 190 more rows #> # ℹ 2 more variables: total_all_children <dbl>, child_labour_sm <dbl>"},{"path":"https://bayesiandemography.github.io/smoothscale/reference/estimate_alpha_beta.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate Parameters Used in Smoothing — estimate_alpha_beta","title":"Estimate Parameters Used in Smoothing — estimate_alpha_beta","text":"Estimate alpha beta parameters x size, maximising posterior density. internal function, normally called directly end users.","code":""},{"path":"https://bayesiandemography.github.io/smoothscale/reference/estimate_alpha_beta.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate Parameters Used in Smoothing — estimate_alpha_beta","text":"","code":"estimate_alpha_beta(x, size, prior_cases)"},{"path":"https://bayesiandemography.github.io/smoothscale/reference/estimate_alpha_beta.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate Parameters Used in Smoothing — estimate_alpha_beta","text":"x vector non-negative values. size vector non-negative values prior_cases non-negative scalar.","code":""},{"path":"https://bayesiandemography.github.io/smoothscale/reference/estimate_alpha_beta.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate Parameters Used in Smoothing — estimate_alpha_beta","text":"named numeric vector length 2.","code":""},{"path":"https://bayesiandemography.github.io/smoothscale/reference/estimate_alpha_beta.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Estimate Parameters Used in Smoothing — estimate_alpha_beta","text":"posterior density formed multiplying beta-binomial likelihood half-Cauchy prior sum alpha beta.","code":""},{"path":[]},{"path":"https://bayesiandemography.github.io/smoothscale/reference/estimate_alpha_beta.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate Parameters Used in Smoothing — estimate_alpha_beta","text":"","code":"estimate_alpha_beta(x = syn_census$child_labour,                     size = syn_census$all_children,                     prior_cases = 100) #>     alpha      beta  #>  6.254641 17.388136"},{"path":"https://bayesiandemography.github.io/smoothscale/reference/scale_prob.html","id":null,"dir":"Reference","previous_headings":"","what":"Scale Probabilities — scale_prob","title":"Scale Probabilities — scale_prob","text":"Scale probabilities consistent pre-specified benchmarks, totals obtained national survey.","code":""},{"path":"https://bayesiandemography.github.io/smoothscale/reference/scale_prob.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Scale Probabilities — scale_prob","text":"","code":"scale_prob(prob_unscaled, prob_target, wt = NULL)"},{"path":"https://bayesiandemography.github.io/smoothscale/reference/scale_prob.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Scale Probabilities — scale_prob","text":"prob_unscaled Reported probability attribute interest. numeric vector values 0 1. prob_target Benchmark probability. number 0 1. wt Weights use calculating overall unscaled probability individual unscaled probabilities. Optional.","code":""},{"path":"https://bayesiandemography.github.io/smoothscale/reference/scale_prob.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Scale Probabilities — scale_prob","text":"numeric vector scaled probabilities.","code":""},{"path":[]},{"path":"https://bayesiandemography.github.io/smoothscale/reference/scale_prob.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Scale Probabilities — scale_prob","text":"","code":"set.seed(10) p1 <- runif(n = 10) p2 <- 0.6 p1_scaled <- scale_prob(prob_unscaled = p1,                         prob_target = p2) rbind(p1, p1_scaled) #>                [,1]      [,2]      [,3]      [,4]       [,5]      [,6] #> p1        0.5074782 0.3067685 0.4269077 0.6931021 0.08513597 0.2254366 #> p1_scaled 0.6803277 0.5500567 0.6280333 0.8008073 0.40620568 0.4972681 #>                [,7]      [,8]      [,9]     [,10] #> p1        0.2745305 0.2723051 0.6158293 0.4296715 #> p1_scaled 0.5291326 0.5276882 0.7506532 0.6298272 mean(p1) #> [1] 0.3837165 mean(p1_scaled) #> [1] 0.6  ## use tidyverse functions to scale separately ## within age-sex groups census <- smoothscale::syn_census survey <- smoothscale::syn_survey library(dplyr) #>  #> Attaching package: ‘dplyr’ #> The following objects are masked from ‘package:stats’: #>  #>     filter, lag #> The following objects are masked from ‘package:base’: #>  #>     intersect, setdiff, setequal, union  census |>   left_join(survey, by = c(\"age\", \"sex\")) |>   mutate(prob_direct = child_labour / all_children) |>   group_by(age, sex) |>   mutate(prob_scaled = scale_prob(prob_unscaled = prob_direct,                                   prob_target = prob_child_labour)) #> # A tibble: 100 × 8 #> # Groups:   age, sex [4] #>    area    age   sex    child_labour all_children prob_child_labour prob_direct #>    <chr>   <chr> <chr>         <int>        <dbl>             <dbl>       <dbl> #>  1 Area 01 5-9   Female          134          372             0.297      0.360  #>  2 Area 02 5-9   Female           14           35             0.297      0.4    #>  3 Area 03 5-9   Female           92          388             0.297      0.237  #>  4 Area 04 5-9   Female           46          345             0.297      0.133  #>  5 Area 05 5-9   Female           25          102             0.297      0.245  #>  6 Area 06 5-9   Female            2            5             0.297      0.4    #>  7 Area 07 5-9   Female            4           13             0.297      0.308  #>  8 Area 08 5-9   Female           10           34             0.297      0.294  #>  9 Area 09 5-9   Female            2           52             0.297      0.0385 #> 10 Area 10 5-9   Female          578         2087             0.297      0.277  #> # ℹ 90 more rows #> # ℹ 1 more variable: prob_scaled <dbl>"},{"path":"https://bayesiandemography.github.io/smoothscale/reference/smooth_prob.html","id":null,"dir":"Reference","previous_headings":"","what":"Smooth Probabilities — smooth_prob","title":"Smooth Probabilities — smooth_prob","text":"Calculate probabilities multiple population. Given data number 'trials' 'succession' population, calculate probability success population. instance, given data number respondent, number employed respondents, area, calculate probability employed area. probabilities smoothed: values shifted towards overall mean, values based small sample sizes shifted furtherst.","code":""},{"path":"https://bayesiandemography.github.io/smoothscale/reference/smooth_prob.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Smooth Probabilities — smooth_prob","text":"","code":"smooth_prob(x, size, prior_cases = 10)"},{"path":"https://bayesiandemography.github.io/smoothscale/reference/smooth_prob.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Smooth Probabilities — smooth_prob","text":"x Number successes population. numeric vector. size Number trials population. numeric vector. prior_cases Parameter controlling smoothing. Default 10.","code":""},{"path":"https://bayesiandemography.github.io/smoothscale/reference/smooth_prob.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Smooth Probabilities — smooth_prob","text":"numeric vector smoothed probabilities.","code":""},{"path":"https://bayesiandemography.github.io/smoothscale/reference/smooth_prob.html","id":"stratifying","dir":"Reference","previous_headings":"","what":"Stratifying","title":"Smooth Probabilities — smooth_prob","text":"often appropriate stratify population smooth separately within strata. instance, estimating probabilities employed, may appropriate divide population strata defined age sex. easiest way stratified smoothing use grouped data frames. See example.","code":""},{"path":"https://bayesiandemography.github.io/smoothscale/reference/smooth_prob.html","id":"prior-counts","dir":"Reference","previous_headings":"","what":"prior_counts","title":"Smooth Probabilities — smooth_prob","text":"argument prior_counts controls degree smoothing. noticeable effect number areas, population per area, small. Larger values prior_counts produce smoothing.","code":""},{"path":"https://bayesiandemography.github.io/smoothscale/reference/smooth_prob.html","id":"mathematical-details","dir":"Reference","previous_headings":"","what":"Mathematical details","title":"Smooth Probabilities — smooth_prob","text":"smoothing based model $$x_k \\sim \\text{Binom}(n_k, \\pi_k)$$ $$\\pi_k \\sim \\text{Beta}(\\lambda \\nu, (1 - \\lambda) \\nu)$$ $$\\lambda \\sim \\text{Unif}(0, 1)$$ $$\\nu \\sim \\text{LogNormal}^+(\\log M, 1)$$ \\(k\\) indexes area population, \\(x_k\\) number successes, specified argument x \\(n_k\\) number trials, specified argument size \\(\\pi_k\\) probability success, \\(M\\) control smoothing, can specified argument prior_counts. smooth_prob() returns \\(\\hat{\\pi}_k\\), maximum posterior density estimate \\(\\pi_k\\). \"direct\" (unsmoothed) estimate probability success \\(x_k / n_k\\). details model, see vignette LINK VIGNETTE.","code":""},{"path":"https://bayesiandemography.github.io/smoothscale/reference/smooth_prob.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Smooth Probabilities — smooth_prob","text":"","code":"## use synthetic census data census <- smoothscale::syn_census  ## smooth all groups towards the national level smoothed <- smooth_prob(x = census$child_labour,                         size = census$all_children) smoothed #>   [1] 0.3549757 0.3483956 0.2386031 0.1411431 0.2486301 0.2904461 0.2811255 #>   [8] 0.2828551 0.1052609 0.2768318 0.1608094 0.2004207 0.2446564 0.2304158 #>  [15] 0.2110614 0.2561533 0.1905153 0.2172556 0.2017625 0.2611232 0.2173088 #>  [22] 0.2145986 0.2994043 0.2539228 0.1639726 0.4176366 0.2514717 0.2754479 #>  [29] 0.1457469 0.2343583 0.3653098 0.2452549 0.2778678 0.1686767 0.2898178 #>  [36] 0.1665318 0.2057348 0.2526217 0.2426039 0.2149188 0.1887129 0.3004677 #>  [43] 0.2658116 0.1625439 0.1875074 0.1442691 0.2001372 0.2509286 0.2799954 #>  [50] 0.2273524 0.4307438 0.4802877 0.3179332 0.2053953 0.3320846 0.2904461 #>  [57] 0.2732541 0.3250327 0.2609691 0.3508330 0.1937606 0.2262503 0.1815952 #>  [64] 0.2304158 0.3077062 0.3558618 0.3045517 0.2452549 0.2362838 0.2526217 #>  [71] 0.2760318 0.2207024 0.2535269 0.2890901 0.2109253 0.5185639 0.4981704 #>  [78] 0.4011522 0.1990179 0.2697980 0.3160477 0.2811255 0.3643850 0.2644619 #>  [85] 0.4062783 0.2412001 0.1792203 0.3077176 0.2073400 0.2747700 0.2989522 #>  [92] 0.2973610 0.2930483 0.1985837 0.2526217 0.2430911 0.2759489 0.3158740 #>  [99] 0.3851219 0.2584483  ## compare smoothed and unsmoothed (\"direct\") estimates unsmoothed <- census$child_labour / census$all_children rbind(head(smoothed), head(unsmoothed)) #>           [,1]      [,2]      [,3]      [,4]      [,5]      [,6] #> [1,] 0.3549757 0.3483956 0.2386031 0.1411431 0.2486301 0.2904461 #> [2,] 0.3602151 0.4000000 0.2371134 0.1333333 0.2450980 0.4000000  ## use tidyverse functions to smooth ## each age-sex group towards a ## different average library(dplyr, warn.conflicts = FALSE) census |>   group_by(age, sex) |>   mutate(smoothed = smooth_prob(x = child_labour,                                 size = all_children)) #> # A tibble: 100 × 6 #> # Groups:   age, sex [4] #>    area    age   sex    child_labour all_children smoothed #>    <chr>   <chr> <chr>         <int>        <dbl>    <dbl> #>  1 Area 01 5-9   Female          134          372   0.351  #>  2 Area 02 5-9   Female           14           35   0.325  #>  3 Area 03 5-9   Female           92          388   0.236  #>  4 Area 04 5-9   Female           46          345   0.140  #>  5 Area 05 5-9   Female           25          102   0.241  #>  6 Area 06 5-9   Female            2            5   0.252  #>  7 Area 07 5-9   Female            4           13   0.252  #>  8 Area 08 5-9   Female           10           34   0.264  #>  9 Area 09 5-9   Female            2           52   0.0995 #> 10 Area 10 5-9   Female          578         2087   0.276  #> # ℹ 90 more rows"},{"path":"https://bayesiandemography.github.io/smoothscale/reference/smoothscale-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Package 'smoothscale' — smoothscale-package","title":"Package 'smoothscale' — smoothscale-package","text":"smoothscale contains two functions simple small area estimation: smooth_prob() deals sampling error probabilities pulling towards overall average scale_prob() deals measurement error probabilities scaling consistent (reliable) overall total!","code":""},{"path":"https://bayesiandemography.github.io/smoothscale/reference/smoothscale-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Package 'smoothscale' — smoothscale-package","text":"smoothscale also contains synthetic dataset called syn_census.","code":""},{"path":[]},{"path":"https://bayesiandemography.github.io/smoothscale/reference/syn_census.html","id":null,"dir":"Reference","previous_headings":"","what":"A synthetic census dataset — syn_census","title":"A synthetic census dataset — syn_census","text":"synthetic (ie made-) dataset, illustrating sort tabulations can produced census file. synthetic data measure child labour area level.","code":""},{"path":"https://bayesiandemography.github.io/smoothscale/reference/syn_census.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A synthetic census dataset — syn_census","text":"","code":"syn_census"},{"path":"https://bayesiandemography.github.io/smoothscale/reference/syn_census.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A synthetic census dataset — syn_census","text":"tibble 100 rows following columns: area: Geographical area, numbered 1 25 age: \"5-9\" \"10-14\"` sex: \"Female\" \"Male\" child_labour: Number children involved child labour all_children: Total number children, including involved child labour","code":""},{"path":"https://bayesiandemography.github.io/smoothscale/reference/syn_survey.html","id":null,"dir":"Reference","previous_headings":"","what":"A synthetic survey dataset — syn_survey","title":"A synthetic survey dataset — syn_survey","text":"synthetic (ie made-) dataset, illustrating sort values can produced survey. synthetic data measure child labour national level","code":""},{"path":"https://bayesiandemography.github.io/smoothscale/reference/syn_survey.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A synthetic survey dataset — syn_survey","text":"","code":"syn_survey"},{"path":"https://bayesiandemography.github.io/smoothscale/reference/syn_survey.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A synthetic survey dataset — syn_survey","text":"tibble 4 rows following columns: age: \"5-9\" \"10-14\"` sex: \"Female\" \"Male\" prob_child_labour: Probability child involve din child labour. Assumed accurate.","code":""}]
